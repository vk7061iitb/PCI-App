import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';
import 'package:printing/printing.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import '../../../../Objects/data.dart';
import '../../../../Utils/set_road_stats.dart';
import '../../../Models/stats_data.dart';
import '../../Controllers/map_page_controller.dart';
import '../../Controllers/user_data_controller.dart';

class RoadStatisticsPdfPage extends StatefulWidget {
  final int id;
  final String filename;

  const RoadStatisticsPdfPage({
    super.key,
    required this.id,
    required this.filename,
  });

  @override
  RoadStatisticsPdfPageState createState() => RoadStatisticsPdfPageState();
}

class RoadStatisticsPdfPageState extends State<RoadStatisticsPdfPage> {
  late Future<pw.Document> _pdfDocumentFuture;
  late final Map<String, dynamic> user;
  @override
  void initState() {
    super.initState();
    _pdfDocumentFuture = _generatePdfDocument();
    getUser();
  }

  void getUser() {
    final userDataController = UserDataController();
    user = userDataController.storage.read('user');
  }

  Future<pw.Document> _generatePdfDocument() async {
    // Fetch road statistics (similar to previous implementations)
    final mapPageController = Get.find<MapPageController>();

    // Clear previous data
    mapPageController.roadOutputData = [];
    List<Map<String, dynamic>> res =
        await localDatabase.queryRoadOutputData(jouneyID: widget.id);
    mapPageController.roadOutputData.add(res);

    if (mapPageController.roadStats.isNotEmpty) {
      mapPageController.roadStats.clear();
      mapPageController.segStats.clear();
    }

    final completeStats =
        setRoadStatistics(journeyData: res, filename: widget.filename);
    mapPageController.roadStats = completeStats[0] as List<RoadStats>;
    mapPageController.segStats = completeStats[1] as List<SegStats>;

    // Create PDF document
    final pdf = pw.Document();

    // Add content to PDF
    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        build: (context) => _buildPdfContent(mapPageController),
        header: (context) => _buildPdfHeader(),
        footer: (context) => _buildPdfFooter(context),
      ),
    );

    return pdf;
  }

  List<pw.Widget> _buildPdfContent(MapPageController mapPageController) {
    final List<pw.Widget> content = [];

    // Title
    content.add(pw.Text(
      'Road Statistics Report',
      style: pw.TextStyle(
        fontSize: 20,
        fontWeight: pw.FontWeight.bold,
      ),
    ));
    content.add(
      pw.SizedBox(height: 10),
    );
    content.add(pw.Text(
      'Generated from: ${widget.filename}',
      style: pw.TextStyle(
        fontSize: 12,
        color: PdfColors.grey,
      ),
    ));
    content.add(
      pw.RichText(
        text: pw.TextSpan(
          text: 'Generated by: ',
          style: pw.TextStyle(
            fontSize: 12,
            color: PdfColors.grey,
          ),
          children: [
            pw.TextSpan(
              text: user['email'],
              style: pw.TextStyle(
                fontWeight: pw.FontWeight.bold,
              ),
            ),
          ],
        ),
      ),
    );
    content.add(pw.SizedBox(height: 20));
    // Iterate through road stats
    for (int roadIndex = 0;
        roadIndex < mapPageController.roadStats.length;
        roadIndex++) {
      final roadStats = mapPageController.roadStats[roadIndex];
      final segStats = mapPageController.segStats[roadIndex];

      // Road Name Section
      content.add(pw.Text(
        roadStats.roadName,
        style: pw.TextStyle(
          fontSize: 20,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 10));

      // Prediction Based Statistics
      content.add(pw.Text(
        'Prediction Based Statistics',
        style: pw.TextStyle(
          fontSize: 16,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));

      // Overall Summary
      content.add(pw.Text(
        'Overall Summary',
        style: pw.TextStyle(
          fontSize: 14,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));
      content.add(_buildStatTable(roadStats.predStats));
      content.add(pw.SizedBox(height: 10));

      // Segment-wise Details
      content.add(pw.Text(
        'Segment-wise Details',
        style: pw.TextStyle(
          fontSize: 14,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));
      content.add(_buildSegmentTable(segStats.predictedStats));
      content.add(pw.SizedBox(height: 20));

      // Velocity Based Statistics
      content.add(pw.Text(
        'Velocity Based Statistics',
        style: pw.TextStyle(
          fontSize: 16,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));

      // Overall Summary
      content.add(pw.Text(
        'Overall Summary',
        style: pw.TextStyle(
          fontSize: 14,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));
      content.add(_buildStatTable(roadStats.velStats));
      content.add(pw.SizedBox(height: 10));

      // Segment-wise Details
      content.add(pw.Text(
        'Segment-wise Details',
        style: pw.TextStyle(
          fontSize: 14,
          fontWeight: pw.FontWeight.bold,
        ),
      ));
      content.add(pw.SizedBox(height: 5));
      content.add(_buildSegmentTable(segStats.velocityStats));

      // Page break between roads
      content.add(pw.NewPage());
    }

    return content;
  }

  pw.Widget _buildStatTable(List<dynamic> statsList) {
    return pw.TableHelper.fromTextArray(
      context: null,
      data: [
        ['PCI', 'Distance (km)', 'Velocity (kmph)', 'No. of Segments'],
        ...statsList.map((stats) => [
              stats.pci.toString(),
              (double.parse(stats.distanceTravelled) / 1000).toStringAsFixed(3),
              (double.parse(stats.avgVelocity) * 3.6).toStringAsFixed(3),
              stats.numberOfSegments.toString(),
            ]),
      ],
      headerStyle: pw.TextStyle(
        fontWeight: pw.FontWeight.bold,
      ),
      cellStyle: pw.TextStyle(),
      border: pw.TableBorder.all(color: PdfColors.black),
      headerDecoration: pw.BoxDecoration(color: PdfColors.grey300),
    );
  }

  pw.Widget _buildSegmentTable(List<SegmentStats> stats) {
    return pw.TableHelper.fromTextArray(
      context: null,
      data: [
        [
          'Name',
          'Road No.',
          'Seg. No.',
          'From',
          'To',
          'Distance (km)',
          'PCI',
          'Remarks'
        ],
        ...stats.map((seg) => [
              seg.name,
              seg.roadNo,
              seg.segmentNo,
              seg.from,
              seg.to,
              seg.distance,
              seg.pci,
              seg.remarks,
            ]),
      ],
      headerStyle: pw.TextStyle(
        fontWeight: pw.FontWeight.bold,
      ),
      cellStyle: pw.TextStyle(),
      border: pw.TableBorder.all(color: PdfColors.black),
      headerDecoration: pw.BoxDecoration(color: PdfColors.grey300),
    );
  }

  pw.Widget _buildPdfHeader() {
    return pw.Container(
      alignment: pw.Alignment.centerRight,
      margin: const pw.EdgeInsets.only(bottom: 10),
      child: pw.Text(
        'Report Generated on: ${DateFormat('dd/MM/yyyy HH:mm').format(DateTime.now())}',
        style: pw.TextStyle(
          fontSize: 12,
          color: PdfColors.grey,
        ),
      ),
    );
  }

  pw.Widget _buildPdfFooter(pw.Context context) {
    return pw.Container(
      alignment: pw.Alignment.centerRight,
      margin: const pw.EdgeInsets.only(top: 10),
      child: pw.Text(
        'Page ${context.pageNumber} of ${context.pagesCount}',
        style: pw.TextStyle(
          fontSize: 10,
          color: PdfColors.grey,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        title: Text(
          'Road Statistics PDF',
          style: GoogleFonts.inter(
            fontSize: 24,
            fontWeight: FontWeight.w600,
            color: Colors.black,
          ),
        ),
        backgroundColor: backgroundColor,
        foregroundColor: Colors.transparent,
        shadowColor: Colors.transparent,
        scrolledUnderElevation: 0,
        elevation: 0,
        actions: [
          /* IconButton(
            icon: Icon(Icons.download),
            onPressed: () async {
              final pdf = await _pdfDocumentFuture;
              final path = await localDatabase.getReportDir();
              final file = File('$path/${widget.filename}.pdf');
              file.writeAsBytesSync(await pdf.save());
            },
          ), */
          IconButton(
            padding: EdgeInsets.zero,
            icon: Icon(
              Icons.share,
              color: Colors.black,
            ),
            onPressed: () async {
              final pdf = await _pdfDocumentFuture;
              await Printing.sharePdf(
                bytes: await pdf.save(),
                filename: '${widget.filename}_road_statistics.pdf',
              );
            },
          ),
        ],
      ),
      body: FutureBuilder<pw.Document>(
        future: _pdfDocumentFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Center(
              child: CircularProgressIndicator(),
            );
          }

          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }

          return PdfPreview(
            build: (format) async {
              final pdf = snapshot.data!;
              return pdf.save();
            },
            onShared: (context) {
              //
            },
            allowPrinting: false,
            useActions: false,
            allowSharing: true,
            scrollViewDecoration: const BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.all(Radius.circular(10)),
            ),
            pdfPreviewPageDecoration: const BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.all(Radius.circular(10)),
            ),
          );
        },
      ),
    );
  }
}
